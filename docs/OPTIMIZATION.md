# Рекомендации по оптимизации PDF Service

Документ содержит рекомендации по оптимизации сервиса, основанные на результатах профилирования от 12.02.2024.

## Текущие метрики производительности

### Общие показатели
- Среднее время обработки запроса: 4.222 сек
- Пропускная способность: 1.53 запроса в секунду
- Размер ответа: стабильный, 100273 байт (~98KB)

### Распределение времени обработки
- DOCX генерация: 
  - Среднее: 4.219 сек (99.9% от общего времени)
  - Медиана: 3.644 сек
  - Максимум: 7.581 сек
- PDF конвертация:
  - Среднее: 0.003 сек (0.1% от общего времени)
  - Стабильное отклонение: 0.002 сек

## Приоритетные направления оптимизации

### 1. Оптимизация генерации DOCX (Критический приоритет)
- **Проблема**: 
  - 45.45% CPU времени
  - 38.36% (37.01MB) использования памяти
  - Большой разброс времени выполнения (2.7-7.5 сек)
  - Реализация на Python является узким местом производительности

- **Анализ текущей Python-реализации**:
  - Узкие места в `generate_docx.py`:
    - Использование `docxtpl` библиотеки, которая медленно обрабатывает шаблоны
    - Избыточное создание потоков для простых операций форматирования дат
    - Неэффективное использование кэша шаблонов (in-memory без ограничений)
    - Частый запуск сборщика мусора
    - Избыточное логирование
    - JSON сериализация/десериализация для каждого запроса

- **Быстрые оптимизации (1-2 дня)**:
  - [ ] Оптимизировать работу с шаблонами:
    - Заменить `docxtpl` на более быструю библиотеку `python-docx-template`
    - Предварительно компилировать шаблоны при старте
    - Использовать LRU-кэш с ограничением по размеру
  - [ ] Улучшить обработку данных:
    - Заменить ThreadPoolExecutor на простые синхронные вызовы для форматирования дат
    - Использовать `strptime`/`strftime` вместо `datetime.fromisoformat`
    - Оптимизировать генерацию информации о заявителе
  - [ ] Оптимизировать память:
    - Удалить избыточный вызов `gc.collect()`
    - Уменьшить уровень логирования до WARNING
    - Использовать `__slots__` для классов данных

- **Среднесрочные оптимизации (1-2 недели)**:
  - [ ] Переписать критические участки на Cython:
    - Форматирование дат
    - Генерация информации о заявителе
    - Работа с JSON
  - [ ] Оптимизировать межпроцессное взаимодействие:
    - Реализовать пул Python-процессов в Go
    - Использовать Protocol Buffers вместо JSON
    - Добавить бинарный формат для передачи данных

- **Долгосрочные оптимизации (2-4 недели)**:
  - [ ] Переписать генерацию DOCX на Go:
    - Использовать UniDoc для прямой генерации DOCX
    - Реализовать кэширование на уровне Go
    - Избавиться от Python полностью

- **Оптимизации существующего решения**:
  - [ ] Реализовать кэширование часто используемых шаблонов:
    - Хранить предварительно обработанные шаблоны в памяти
    - Использовать LRU-кэш для популярных комбинаций данных
  - [ ] Оптимизировать межпроцессное взаимодействие:
    - Использовать постоянный Python-процесс вместо создания нового для каждого запроса
    - Реализовать пул Python-процессов
    - Использовать более эффективный способ передачи данных (например, через shared memory)
  - [ ] Оптимизировать работу с памятью:
    - Внедрить пул буферов для переиспользования
    - Предварительно резервировать память под известные размеры
    - Минимизировать копирование данных

- **Метрики для отслеживания прогресса**:
  - Целевое среднее время генерации DOCX: < 1 сек
  - Целевое максимальное время: < 2 сек
  - Целевое использование памяти: < 20MB
  - Целевая пропускная способность: > 5 запросов в секунду

### 2. Оптимизация конвертации PDF (Средний приоритет)
- **Проблема**:
  - 18.18% CPU времени
  - 14.20% (13.70MB) использования памяти
- **Рекомендации**:
  - [ ] Реализовать параллельную обработку конвертаций
  - [ ] Оптимизировать размер передаваемых данных
  - [ ] Рассмотреть возможность асинхронной конвертации для больших документов

### 3. Оптимизация HTTP и Middleware (Средний приоритет)
- **Проблема**: 
  - Значительная нагрузка на обработку HTTP-запросов (54.55% в gin.handleHTTPRequest)
- **Рекомендации**:
  - [ ] Оптимизировать middleware stack
  - [ ] Пересмотреть необходимость каждого middleware
  - [ ] Рассмотреть более легковесные альтернативы для некритичных middleware

### 4. Управление памятью (Средний приоритет)
- **Проблема**:
  - Большое количество аллокаций в буферах (11.45% на bytes.growSlice)
  - 13.70% на сжатие данных (compress/flate)
- **Рекомендации**:
  - [ ] Внедрить sync.Pool для переиспользования буферов
  - [ ] Предварительно резервировать память для буферов известного размера
  - [ ] Оптимизировать начальные размеры аллокаций
  - [ ] Проанализировать возможность уменьшения размера промежуточных данных

### 5. Оптимизация системных вызовов (Низкий приоритет)
- **Проблема**:
  - 31.82% CPU времени на системные вызовы
- **Рекомендации**:
  - [ ] Оптимизировать I/O операции
  - [ ] Увеличить буферизацию где возможно
  - [ ] Рассмотреть использование mmap для больших файлов

## Мониторинг прогресса

После внедрения каждой оптимизации необходимо:
1. Провести повторное профилирование
2. Сравнить метрики с базовыми показателями
3. Обновить статус рекомендаций в этом документе

## Инструменты профилирования

Для профилирования используются:
```bash
# Профилирование CPU и памяти
python scripts/profile_service.py --pod-name <pod-name> --duration 60 --load-test --load-test-concurrency 10 --load-test-requests 100

# Нагрузочное тестирование
python scripts/load_test.py -c 10 -r 100
```

## История оптимизаций

### 12.02.2024 - Базовое профилирование
- Проведено начальное профилирование
- Определены основные направления оптимизации
- Создан документ с рекомендациями 